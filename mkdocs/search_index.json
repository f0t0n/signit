{
    "docs": [
        {
            "location": "/", 
            "text": "SignIt\n\n\n\n\nAbout\n\n\nSignIt\n is a helper-library to create and verify HMAC (HMAC-SHA256 by default) signatures that could be used to sign requests to the APIs.\n\n\n\n\nUse cases\n\n\nOn the \nclient\n side you could\n\n\n\n\nsign your requests using \nsignit.signature.create()\n\n\n\n\nOn the \nserver\n side you could \n\n\n\n\nparse a signature retrieved from request header or query string using \nsignit.signature.parse()\n\n\nverify retrieved signature using \nsignit.signature.verify()\n\n\ngenerate access and secret keys for client using \nsignit.key.generate()\n\n\n\n\n\n\nExample of usage (client)\n\n\nimport datetime\nimport requests\nimport signit\n\nACCESS_KEY = 'MY_ACCESS_KEY'\nSECRET_KEY = 'MY_SECRET_KEY'\n\ndef create_user(user: dict) -\n bool:\n    msg = str(datetime.datetime.utcnow().timestamp())\n    auth = signit.signature.create(MY_ACCESS_KEY, MY_SECRET_KEY, msg)\n    headers = {\n        'Unix-Timestamp': msg,\n        'Authorization': auth,\n    }\n    r = requests.post('http://example.com/users', json=user, headers=headers)\n    return r.status_code == 201\n\n\n\n\nThe Authorization header will look like\n\n\nAuthorization: HMAC-SHA256 MY_ACCESS_KEY:0947c88ce16d078dde4a2aded1fe4627643a378757dccc3428c19569fea99542\n\n\n\n\n\n\nExample of usage (server)\n\n\nThe server has issued an access key and a secret key for you. And only you and the server know the secret key.\n\n\nSo that the server could identify you by your public access key and ensure that you used the secret key to produce a hash of the message in this way:\n\n\n# ...somewhere in my_api/resources/user.py\nimport signit\nfrom aiohttp import web\nfrom psycopg2 import IntegrityError\n\nasync def post(request):\n    message = request.headers['Unix-Timestamp']\n    access_key, signature = signit.signature.parse(request.headers['Authorization'])\n    secret_key = await get_secret_key_from_db(access_key)\n    if not signit.signature.verify(access_key, secret_key, message, signature):\n        raise web.HTTPUnauthorized('Invalid signature')\n    try:\n        await create_user(request)\n    except IntegrityError:\n        raise web.HTTPConflict()\n    return web.HTTPCreated()\n\n\n\n\nAdditionally if you use a \nUnix-Timestamp\n as a message message the server could check if the request is too old and deny with \n401\n to protect against \"replay attacks\".", 
            "title": "Home"
        }, 
        {
            "location": "/#signit", 
            "text": "", 
            "title": "SignIt"
        }, 
        {
            "location": "/#about", 
            "text": "SignIt  is a helper-library to create and verify HMAC (HMAC-SHA256 by default) signatures that could be used to sign requests to the APIs.", 
            "title": "About"
        }, 
        {
            "location": "/#use-cases", 
            "text": "On the  client  side you could   sign your requests using  signit.signature.create()   On the  server  side you could    parse a signature retrieved from request header or query string using  signit.signature.parse()  verify retrieved signature using  signit.signature.verify()  generate access and secret keys for client using  signit.key.generate()", 
            "title": "Use cases"
        }, 
        {
            "location": "/#example-of-usage-client", 
            "text": "import datetime\nimport requests\nimport signit\n\nACCESS_KEY = 'MY_ACCESS_KEY'\nSECRET_KEY = 'MY_SECRET_KEY'\n\ndef create_user(user: dict) -  bool:\n    msg = str(datetime.datetime.utcnow().timestamp())\n    auth = signit.signature.create(MY_ACCESS_KEY, MY_SECRET_KEY, msg)\n    headers = {\n        'Unix-Timestamp': msg,\n        'Authorization': auth,\n    }\n    r = requests.post('http://example.com/users', json=user, headers=headers)\n    return r.status_code == 201  The Authorization header will look like  Authorization: HMAC-SHA256 MY_ACCESS_KEY:0947c88ce16d078dde4a2aded1fe4627643a378757dccc3428c19569fea99542", 
            "title": "Example of usage (client)"
        }, 
        {
            "location": "/#example-of-usage-server", 
            "text": "The server has issued an access key and a secret key for you. And only you and the server know the secret key.  So that the server could identify you by your public access key and ensure that you used the secret key to produce a hash of the message in this way:  # ...somewhere in my_api/resources/user.py\nimport signit\nfrom aiohttp import web\nfrom psycopg2 import IntegrityError\n\nasync def post(request):\n    message = request.headers['Unix-Timestamp']\n    access_key, signature = signit.signature.parse(request.headers['Authorization'])\n    secret_key = await get_secret_key_from_db(access_key)\n    if not signit.signature.verify(access_key, secret_key, message, signature):\n        raise web.HTTPUnauthorized('Invalid signature')\n    try:\n        await create_user(request)\n    except IntegrityError:\n        raise web.HTTPConflict()\n    return web.HTTPCreated()  Additionally if you use a  Unix-Timestamp  as a message message the server could check if the request is too old and deny with  401  to protect against \"replay attacks\".", 
            "title": "Example of usage (server)"
        }, 
        {
            "location": "/key/", 
            "text": "Key\n\n\n\n\nModule description\n\n\nThe module \nsignit.key\n implements a functionality that allows you to generate random keys to use later for HMAC signature creating and user identification.\n\n\n\n\nModule interface\n\n\n\n\nsignit.key.generate(key_length=KEY_LENGTH, key_chars=KEY_CHARS)\n\n\n\n\nGenerates a random key.\n\n\nParameters:\n\n\n\n\nkey_length\n (\nint\n) - a length of key to generate (default \n32\n)\n\n\nkey_chars\n (\nstr\n) - chars to use for random key generating (default \n[a-zA-Z0-9]\n)\n\n\n\n\nReturns\n (\nstr\n) - a generated key.\n\n\nExample of usage:\n\n\nimport signit\nimport string\n\nif __name__ == '__main__':\n    print('Access key:',\n          signit.key.generate(key_length=8, key_chars=string.ascii_lowercase))\n    print('Secret key:',\n          signit.key.generate(key_length=32, key_chars=string.ascii_uppercase))", 
            "title": "Key"
        }, 
        {
            "location": "/key/#key", 
            "text": "", 
            "title": "Key"
        }, 
        {
            "location": "/key/#module-description", 
            "text": "The module  signit.key  implements a functionality that allows you to generate random keys to use later for HMAC signature creating and user identification.", 
            "title": "Module description"
        }, 
        {
            "location": "/key/#module-interface", 
            "text": "signit.key.generate(key_length=KEY_LENGTH, key_chars=KEY_CHARS)   Generates a random key.  Parameters:   key_length  ( int ) - a length of key to generate (default  32 )  key_chars  ( str ) - chars to use for random key generating (default  [a-zA-Z0-9] )   Returns  ( str ) - a generated key.  Example of usage:  import signit\nimport string\n\nif __name__ == '__main__':\n    print('Access key:',\n          signit.key.generate(key_length=8, key_chars=string.ascii_lowercase))\n    print('Secret key:',\n          signit.key.generate(key_length=32, key_chars=string.ascii_uppercase))", 
            "title": "Module interface"
        }, 
        {
            "location": "/signature/", 
            "text": "Signature\n\n\n\n\nModule description\n\n\nThe module \nsignit.signature\n implements a functionality that allows you to create HMAC signature, parse generated signatures and validate the signature (e.g. provided by your API client) against known message, access key and secret key.\n\n\n\n\nModule interface\n\n\n\n\nsignit.signature.create(access_key, secret_key, message, algorithm=sha256, auth_header_prefix=AUTH_PREFIX_HEADER)\n\n\n\n\nCreates a HMAC signature to pass to \nAuthorization\n header or query string.\n\n\nParameters:\n\n\n\n\naccess_key\n (\nstr\n) - A public access key that allows to identify the client\n\n\nsecret_key\n (\nstr\n) - A private secret key to hash the message with\n\n\nmessage\n (\nstr\n) - A message to hash\n\n\nalgorithm\n - Is the digest name, digest constructor or module for the HMAC object to use (default \nhashlib.sha256\n). For more details see \nhmac.new\n\n\n\n\nReturns\n (\nstr\n) - a generated signature in format of \n'\nprefix\n \naccess key\n:\nhmac signature\n'\n\n\n\n\n\n\nsignit.signature.parse(signature, auth_header_prefix=None)\n\n\n\n\nParses a signature created before with \nsignit.signature.create\n.\n\n\nParameters:\n\n\n\n\nsignature\n (\nstr\n) - a signature to parse\n\n\nauth_header_prefix\n (\nstr\n) - a header prefix you expect signature to have. If set, the \nValueError\n will be raised if the \nsignature\n has different prefix.\n\n\n\n\nReturns\n (\ntuple\n) - \n(\naccess_key\n, \nhmac_signature\n)\n tuple\n\n\n\n\n\n\nsignit.signature.verify(access_key, secret_key, message, signature,\n           auth_header_prefix=AUTH_PREFIX_HEADER)\n\n\n\n\nVerifies the signature (e.g. provided by API client) against known \naccess_key\n, \nsecret_key\n and \nmessage\n. \n\n\nIn other words it allows the server side to make sure the \nmessage\n has been hashed with an appropriate \nsecret_key\n that belongs to the client identified by its \naccess_key\n.\n\n\nParameters:\n\n\n\n\naccess_key\n (\nstr\n) - A public access key that allows to identify the client\n\n\nsecret_key\n (\nstr\n) - A private secret key to hash the message with\n\n\nmessage\n (\nstr\n) - A message to hash\n\n\nsignature\n (\nstr\n) - A signature provided by client in format of \n'\nprefix\n \naccess key\n:\nhmac signature\n'\n\n\nauth_header_prefix\n - a header prefix you're expect to see in provided \nsignature\n to reproduce its (signature's) exact copy during the verification.\n\n\n\n\nReturns\n (\nbool\n) - is the provided \nsignature\n valid, namely is successfully verified against known on the server side access, secret key and the message.", 
            "title": "Signature"
        }, 
        {
            "location": "/signature/#signature", 
            "text": "", 
            "title": "Signature"
        }, 
        {
            "location": "/signature/#module-description", 
            "text": "The module  signit.signature  implements a functionality that allows you to create HMAC signature, parse generated signatures and validate the signature (e.g. provided by your API client) against known message, access key and secret key.", 
            "title": "Module description"
        }, 
        {
            "location": "/signature/#module-interface", 
            "text": "signit.signature.create(access_key, secret_key, message, algorithm=sha256, auth_header_prefix=AUTH_PREFIX_HEADER)   Creates a HMAC signature to pass to  Authorization  header or query string.  Parameters:   access_key  ( str ) - A public access key that allows to identify the client  secret_key  ( str ) - A private secret key to hash the message with  message  ( str ) - A message to hash  algorithm  - Is the digest name, digest constructor or module for the HMAC object to use (default  hashlib.sha256 ). For more details see  hmac.new   Returns  ( str ) - a generated signature in format of  ' prefix   access key : hmac signature '    signit.signature.parse(signature, auth_header_prefix=None)   Parses a signature created before with  signit.signature.create .  Parameters:   signature  ( str ) - a signature to parse  auth_header_prefix  ( str ) - a header prefix you expect signature to have. If set, the  ValueError  will be raised if the  signature  has different prefix.   Returns  ( tuple ) -  ( access_key ,  hmac_signature )  tuple    signit.signature.verify(access_key, secret_key, message, signature,\n           auth_header_prefix=AUTH_PREFIX_HEADER)   Verifies the signature (e.g. provided by API client) against known  access_key ,  secret_key  and  message .   In other words it allows the server side to make sure the  message  has been hashed with an appropriate  secret_key  that belongs to the client identified by its  access_key .  Parameters:   access_key  ( str ) - A public access key that allows to identify the client  secret_key  ( str ) - A private secret key to hash the message with  message  ( str ) - A message to hash  signature  ( str ) - A signature provided by client in format of  ' prefix   access key : hmac signature '  auth_header_prefix  - a header prefix you're expect to see in provided  signature  to reproduce its (signature's) exact copy during the verification.   Returns  ( bool ) - is the provided  signature  valid, namely is successfully verified against known on the server side access, secret key and the message.", 
            "title": "Module interface"
        }
    ]
}