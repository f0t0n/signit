{
    "docs": [
        {
            "location": "/", 
            "text": "SignIt\n\n\n\n\n\n\n\n\n\n\nAbout\n\n\nSignIt\n is a helper-library to create and verify HMAC (HMAC-SHA256 by default) signatures that could be used to sign requests to the APIs.\n\n\n\n\nUse cases\n\n\nOn the \nclient\n side you could\n\n\n\n\nsign your requests using \nsignit.signature.create()\n\n\n\n\nOn the \nserver\n side you could \n\n\n\n\nparse a signature retrieved from request header or query string using \nsignit.signature.parse()\n\n\nverify retrieved signature using \nsignit.signature.verify()\n\n\ngenerate access and secret keys for client using \nsignit.key.generate()\n\n\n\n\n\n\nExample of usage (client)\n\n\nimport datetime\nimport requests\nimport signit\n\nACCESS_KEY = 'MY_ACCESS_KEY'\nSECRET_KEY = 'MY_SECRET_KEY'\n\ndef create_user(user: dict) -\n bool:\n    msg = str(datetime.datetime.utcnow().timestamp())\n    auth = signit.signature.create(MY_ACCESS_KEY, MY_SECRET_KEY, msg)\n    headers = {\n        'Unix-Timestamp': msg,\n        'Authorization': auth,\n    }\n    r = requests.post('http://example.com/users', json=user, headers=headers)\n    return r.status_code == 201\n\n\n\n\nThe Authorization header will look like\n\n\nAuthorization: HMAC-SHA256 MY_ACCESS_KEY:0947c88ce16d078dde4a2aded1fe4627643a378757dccc3428c19569fea99542\n\n\n\n\n\n\nExample of usage (server)\n\n\nThe server has issued an access key and a secret key for you. And only you and the server know the secret key.\n\n\nSo that the server could identify you by your public access key and ensure that you used the secret key to produce a hash of the message in this way:\n\n\n# ...somewhere in my_api/resources/user.py\nimport signit\nfrom aiohttp import web\nfrom psycopg2 import IntegrityError\n\nasync def post(request):\n    message = request.headers['Unix-Timestamp']\n    signature = request.headers['Authorization']\n    prefix, access_key, hmac_digest = signit.signature.parse(signature)\n    secret_key = await get_secret_key_from_db(access_key)\n    if not signit.signature.verify(hmac_digest, secret_key, message):\n        raise web.HTTPUnauthorized('Invalid signature')\n    try:\n        await create_user(request)\n    except IntegrityError:\n        raise web.HTTPConflict()\n    return web.HTTPCreated()\n\n\n\n\nAdditionally if you use a \nUnix-Timestamp\n as a message message the server could check if the request is too old and deny with \n401\n to protect against \"replay attacks\".", 
            "title": "Home"
        }, 
        {
            "location": "/#signit", 
            "text": "", 
            "title": "SignIt"
        }, 
        {
            "location": "/#about", 
            "text": "SignIt  is a helper-library to create and verify HMAC (HMAC-SHA256 by default) signatures that could be used to sign requests to the APIs.", 
            "title": "About"
        }, 
        {
            "location": "/#use-cases", 
            "text": "On the  client  side you could   sign your requests using  signit.signature.create()   On the  server  side you could    parse a signature retrieved from request header or query string using  signit.signature.parse()  verify retrieved signature using  signit.signature.verify()  generate access and secret keys for client using  signit.key.generate()", 
            "title": "Use cases"
        }, 
        {
            "location": "/#example-of-usage-client", 
            "text": "import datetime\nimport requests\nimport signit\n\nACCESS_KEY = 'MY_ACCESS_KEY'\nSECRET_KEY = 'MY_SECRET_KEY'\n\ndef create_user(user: dict) -  bool:\n    msg = str(datetime.datetime.utcnow().timestamp())\n    auth = signit.signature.create(MY_ACCESS_KEY, MY_SECRET_KEY, msg)\n    headers = {\n        'Unix-Timestamp': msg,\n        'Authorization': auth,\n    }\n    r = requests.post('http://example.com/users', json=user, headers=headers)\n    return r.status_code == 201  The Authorization header will look like  Authorization: HMAC-SHA256 MY_ACCESS_KEY:0947c88ce16d078dde4a2aded1fe4627643a378757dccc3428c19569fea99542", 
            "title": "Example of usage (client)"
        }, 
        {
            "location": "/#example-of-usage-server", 
            "text": "The server has issued an access key and a secret key for you. And only you and the server know the secret key.  So that the server could identify you by your public access key and ensure that you used the secret key to produce a hash of the message in this way:  # ...somewhere in my_api/resources/user.py\nimport signit\nfrom aiohttp import web\nfrom psycopg2 import IntegrityError\n\nasync def post(request):\n    message = request.headers['Unix-Timestamp']\n    signature = request.headers['Authorization']\n    prefix, access_key, hmac_digest = signit.signature.parse(signature)\n    secret_key = await get_secret_key_from_db(access_key)\n    if not signit.signature.verify(hmac_digest, secret_key, message):\n        raise web.HTTPUnauthorized('Invalid signature')\n    try:\n        await create_user(request)\n    except IntegrityError:\n        raise web.HTTPConflict()\n    return web.HTTPCreated()  Additionally if you use a  Unix-Timestamp  as a message message the server could check if the request is too old and deny with  401  to protect against \"replay attacks\".", 
            "title": "Example of usage (server)"
        }, 
        {
            "location": "/key/", 
            "text": "Key\n\n\n\n\nModule description\n\n\nThe module \nsignit.key\n implements a functionality that allows you to generate random keys to use later for HMAC signature creating and user identification.\n\n\n\n\nModule interface\n\n\n\n\nsignit.key.generate(key_length=KEY_LENGTH, key_chars=KEY_CHARS)\n\n\n\n\nGenerates a random key.\n\n\nParameters:\n\n\n\n\nkey_length\n (\nint\n) - a length of key to generate (default \n32\n)\n\n\nkey_chars\n (\nstr\n) - chars to use for random key generating (default \n[a-zA-Z0-9]\n)\n\n\n\n\nReturns\n (\nstr\n) - a generated key.\n\n\nExample of usage:\n\n\nimport signit\nimport string\n\nif __name__ == '__main__':\n    print('Access key:',\n          signit.key.generate(key_length=8, key_chars=string.ascii_lowercase))\n    print('Secret key:',\n          signit.key.generate(key_length=32, key_chars=string.ascii_uppercase))", 
            "title": "Key"
        }, 
        {
            "location": "/key/#key", 
            "text": "", 
            "title": "Key"
        }, 
        {
            "location": "/key/#module-description", 
            "text": "The module  signit.key  implements a functionality that allows you to generate random keys to use later for HMAC signature creating and user identification.", 
            "title": "Module description"
        }, 
        {
            "location": "/key/#module-interface", 
            "text": "signit.key.generate(key_length=KEY_LENGTH, key_chars=KEY_CHARS)   Generates a random key.  Parameters:   key_length  ( int ) - a length of key to generate (default  32 )  key_chars  ( str ) - chars to use for random key generating (default  [a-zA-Z0-9] )   Returns  ( str ) - a generated key.  Example of usage:  import signit\nimport string\n\nif __name__ == '__main__':\n    print('Access key:',\n          signit.key.generate(key_length=8, key_chars=string.ascii_lowercase))\n    print('Secret key:',\n          signit.key.generate(key_length=32, key_chars=string.ascii_uppercase))", 
            "title": "Module interface"
        }, 
        {
            "location": "/signature/", 
            "text": "Signature\n\n\n\n\nModule description\n\n\nThe module \nsignit.signature\n implements a functionality that allows you to create HMAC signature, parse generated signatures and validate the signature (e.g. provided by your API client) against known message, access key and secret key.\n\n\n\n\nModule interface\n\n\n\n\nsignit.signature.create(access_key, secret_key, message, algorithm=sha256, auth_header_prefix=AUTH_PREFIX_HEADER)\n\n\n\n\nCreates a HMAC signature to pass to \nAuthorization\n header or query string.\n\n\nParameters:\n\n\n\n\naccess_key\n (\nstr\n) - A public access key that allows to identify the client\n\n\nsecret_key\n (\nstr\n) - A private secret key to hash the message with\n\n\nmessage\n (\nstr\n) - A message to hash\n\n\nalgorithm\n - Is the digest name, digest constructor or module for the HMAC object to use (default \nhashlib.sha256\n). For more details see \nhmac.new\n. Used to create a HMAC.\n\n\nauth_header_prefix\n (\nstr\n) - A prefix for \nAuthorization\n header (default \n'HMAC-SHA256'\n).\n\n\n\n\nReturns\n (\nstr\n) - a generated signature in format of \n'\nauth_header_prefix\n \naccess_key\n:\nhmac_hex_digest\n'\n\n\n\n\n\n\nsignit.signature.parse(signature)\n\n\n\n\nParses a signature created before with \nsignit.signature.create\n.\n\n\nParameters:\n\n\n\n\nsignature\n (\nstr\n) - a signature to parse (the value from \nAuthorization\n header).\n\n\n\n\nReturns\n (\nlist\n) - Signagure's parts in form of \n[\nauth_header_prefix\n, \naccess_key\n, \nhmac_hex_digest\n]\n.\n\n\n\n\n\n\nsignit.signature.verify(hmac_hex_digest, secret_key, message, algorithm=sha256)\n\n\n\n\nVerifies the signature (e.g. provided by API client) against known \nsecret_key\n and \nmessage\n. \n\n\nIn other words it allows the server side to make sure the \nmessage\n has been hashed with an appropriate \nsecret_key\n.\n\n\nParameters:\n\n\n\n\nhmac_hex_digest\n (\nstr\n) - A message's hash to check.\nNamely it's \nhmac_hex_digest\n part from the \nAuthorization\n header's value (\n'\nauth_header_prefix\n \naccess_key\n:\nhmac_hex_digest\n'\n).\n\n\nsecret_key\n (\nstr\n) - A private secret key to hash the message with.\n\n\nmessage\n (\nstr\n) - A message to hash.\n\n\nalgorithm\n - Is the digest name, digest constructor or module for the HMAC object to use (default \nhashlib.sha256\n). For more details see \nhmac.new\n. Used to create a HMAC.\n\n\n\n\nReturns\n (\nbool\n) - is the provided \nhmac_hex_digest\n valid, namely is successfully verified against known on the server side secret key and the message.", 
            "title": "Signature"
        }, 
        {
            "location": "/signature/#signature", 
            "text": "", 
            "title": "Signature"
        }, 
        {
            "location": "/signature/#module-description", 
            "text": "The module  signit.signature  implements a functionality that allows you to create HMAC signature, parse generated signatures and validate the signature (e.g. provided by your API client) against known message, access key and secret key.", 
            "title": "Module description"
        }, 
        {
            "location": "/signature/#module-interface", 
            "text": "signit.signature.create(access_key, secret_key, message, algorithm=sha256, auth_header_prefix=AUTH_PREFIX_HEADER)   Creates a HMAC signature to pass to  Authorization  header or query string.  Parameters:   access_key  ( str ) - A public access key that allows to identify the client  secret_key  ( str ) - A private secret key to hash the message with  message  ( str ) - A message to hash  algorithm  - Is the digest name, digest constructor or module for the HMAC object to use (default  hashlib.sha256 ). For more details see  hmac.new . Used to create a HMAC.  auth_header_prefix  ( str ) - A prefix for  Authorization  header (default  'HMAC-SHA256' ).   Returns  ( str ) - a generated signature in format of  ' auth_header_prefix   access_key : hmac_hex_digest '    signit.signature.parse(signature)   Parses a signature created before with  signit.signature.create .  Parameters:   signature  ( str ) - a signature to parse (the value from  Authorization  header).   Returns  ( list ) - Signagure's parts in form of  [ auth_header_prefix ,  access_key ,  hmac_hex_digest ] .    signit.signature.verify(hmac_hex_digest, secret_key, message, algorithm=sha256)   Verifies the signature (e.g. provided by API client) against known  secret_key  and  message .   In other words it allows the server side to make sure the  message  has been hashed with an appropriate  secret_key .  Parameters:   hmac_hex_digest  ( str ) - A message's hash to check.\nNamely it's  hmac_hex_digest  part from the  Authorization  header's value ( ' auth_header_prefix   access_key : hmac_hex_digest ' ).  secret_key  ( str ) - A private secret key to hash the message with.  message  ( str ) - A message to hash.  algorithm  - Is the digest name, digest constructor or module for the HMAC object to use (default  hashlib.sha256 ). For more details see  hmac.new . Used to create a HMAC.   Returns  ( bool ) - is the provided  hmac_hex_digest  valid, namely is successfully verified against known on the server side secret key and the message.", 
            "title": "Module interface"
        }
    ]
}